<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->




<!-- keywords -->




<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="ks-39">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="ks-39">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="Fake it till you make it">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Java学习笔记(Day 12：Java.util:集合框架) · ks-39&#39;s Studio</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href="/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="stylesheet" href="/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href="/assets/favicon.ico">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >ks-39&#39;s home.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Java学习笔记(Day 12：Java.util:集合框架)</a>
            </div>
    </div>
    
    <a class="home-link" href=/>ks-39's home.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/background.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Java学习笔记(Day 12：Java.util:集合框架)
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "JavaSe">JavaSe</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">6k</span>阅读时长: <span class="post-count reading-time">29 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2019/09/15</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="P506-P580"><a href="#P506-P580" class="headerlink" title="P506-P580"></a>P506-P580</h2><hr>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><img src="https://img-blog.csdn.net/20180825111638257?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd3ZWlfNjIw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="集合接口"><br><img src="https://img-blog.csdn.net/20180825111710146?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd3ZWlfNjIw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="集合类"></p>
<hr>
<p>集合与数组的区别：</p>
<ol>
<li>数组长度是固定的，集合长度是可变的。</li>
<li>数组元素类型必须是同一类型，集合元素可以是不同类型。</li>
</ol>
<hr>
<h2 id="集合接口：Collection、List、Set、SortedSet、NavigableSet、Queue。"><a href="#集合接口：Collection、List、Set、SortedSet、NavigableSet、Queue。" class="headerlink" title="集合接口：Collection、List、Set、SortedSet、NavigableSet、Queue。"></a>集合接口：Collection、List、Set、SortedSet、NavigableSet、Queue。</h2><h3 id="1-Collection接口：（所有集合类都实现了该接口）（泛型接口）（无序集合）"><a href="#1-Collection接口：（所有集合类都实现了该接口）（泛型接口）（无序集合）" class="headerlink" title="1. Collection接口：（所有集合类都实现了该接口）（泛型接口）（无序集合）"></a>1. Collection接口：（所有集合类都实现了该接口）（泛型接口）（无序集合）</h3><ol>
<li>集合的顶级接口、泛型接口：interface Collection<e>。</e></li>
<li>实现了该接口的集合类：所有集合类</li>
<li>拓展了Iterable接口，可以使用for循环</li>
<li>包含三个接口：List、Set、Queue</li>
</ol>
<hr>
<h3 id="2-List接口：（继承自Collection）（有序集合）（泛型接口）"><a href="#2-List接口：（继承自Collection）（有序集合）（泛型接口）" class="headerlink" title="2. List接口：（继承自Collection）（有序集合）（泛型接口）"></a>2. List接口：（继承自Collection）（有序集合）（泛型接口）</h3><ol>
<li>泛型接口：interface List<e>。</e></li>
<li>常用方法：<ol>
<li>void add();在列表最后插入元素</li>
<li>void add(index,obj);在指定index插入元素</li>
<li>E get(index);返回index位置的元素</li>
<li>int size();返回列表元素个数</li>
<li>void clear();清空列表元素</li>
<li>boolean isEmpty();判断列表是否为空</li>
<li>E remove(index);移除指定index的元素</li>
<li>boolean contains(Obj obj);判断obj是否在列表中</li>
</ol>
</li>
<li>实现了该接口的集合类：<ol>
<li>ArrayList：实现了一个可变长度数组。例：List<class-name> obj = new ArrayList<class-name>();</class-name></class-name></li>
<li>LinkedList：使用链表结构存储数据，运行速度快。例：List<class-name> obj = new LinkedList<class-name>();</class-name></class-name></li>
</ol>
</li>
<li>输出List列表：for-each循环</li>
</ol>
<hr>
<h3 id="3-Set接口：（继承自Collection）（无序集合）（泛型接口）"><a href="#3-Set接口：（继承自Collection）（无序集合）（泛型接口）" class="headerlink" title="3. Set接口：（继承自Collection）（无序集合）（泛型接口）"></a>3. Set接口：（继承自Collection）（无序集合）（泛型接口）</h3><ol>
<li>泛型接口：interface Set<e>。</e></li>
<li>常用方法：<ol>
<li>void add();在列表最后插入元素</li>
<li>void add(index,obj);在指定index插入元素</li>
<li>E get(index);返回index位置的元素</li>
<li>int size();返回列表元素个数</li>
<li>void clear();清空列表元素</li>
<li>boolean isEmpty();判断列表是否为空</li>
<li>E remove(index);移除指定index的元素</li>
<li>boolean contains(Obj obj);判断obj是否在列表中</li>
</ol>
</li>
<li>实现了该接口的集合类：<ol>
<li>HashSet：是HashMap的相关方法,传入数据后，根据数据的hashCode进行散列运算，得到散列值后再进行运算，确定键值。(使用HashSet存储必须在实体类中重写hashCode方法和equals方法)。例：Set<class-name> obj = new HashSer<class-name>();</class-name></class-name></li>
<li>LinkedHashSet：在HashSet的基础上，新增一个链表，用链表来记录存储的顺序。例：Set<class-name> obj = new LinkedHashSer<class-name>();</class-name></class-name></li>
<li>TreeSet：将存入的数据按存入顺序进行排序，然后输出。如果传入的是一个实体对象，需要传入比较器。并且实体类实现Comparable接口，并重写CompareTo方法。例：Set<class-name> obj = new TreeSet<class-name>();</class-name></class-name></li>
</ol>
</li>
<li>输出Set列表：for-each循环</li>
<li>Set(无序)——&gt;SortedSet(有序)——&gt;NavigableSet</li>
</ol>
<hr>
<h3 id="4-SortedSet接口：（继承自Set接口）（升序存储）（泛型接口）"><a href="#4-SortedSet接口：（继承自Set接口）（升序存储）（泛型接口）" class="headerlink" title="4. SortedSet接口：（继承自Set接口）（升序存储）（泛型接口）"></a>4. SortedSet接口：（继承自Set接口）（升序存储）（泛型接口）</h3><ol>
<li>泛型接口：interface SortedSet<e></e></li>
<li>常用方法同Set</li>
<li>无</li>
<li>输出SortedSet列表：for-each</li>
</ol>
<hr>
<h3 id="5-Queue接口：（继承自Collection）（队列）（先进先出）（泛型接口）"><a href="#5-Queue接口：（继承自Collection）（队列）（先进先出）（泛型接口）" class="headerlink" title="5. Queue接口：（继承自Collection）（队列）（先进先出）（泛型接口）"></a>5. Queue接口：（继承自Collection）（队列）（先进先出）（泛型接口）</h3><ol>
<li>泛型接口：interface Queue<e></e></li>
<li>先进先出</li>
<li>常用方法：<ol>
<li>Collection的方法</li>
<li>E poll()\remove();获取队列头部的元素并移除</li>
<li>E element()\peek();获取但不移除头部元素</li>
</ol>
</li>
</ol>
<hr>
<h3 id="6-Deque接口：（继承自Queue）（双端队列）（先进先出）（后进先出）（泛型接口）"><a href="#6-Deque接口：（继承自Queue）（双端队列）（先进先出）（后进先出）（泛型接口）" class="headerlink" title="6. Deque接口：（继承自Queue）（双端队列）（先进先出）（后进先出）（泛型接口）"></a>6. Deque接口：（继承自Queue）（双端队列）（先进先出）（后进先出）（泛型接口）</h3><p>1、泛型接口：interface Deque<e><br>2、先进先出、后进先出<br>3、常用方法：<br>    1. Queue方法<br>    2. E push()/pop();类似堆栈，入列出列</e></p>
<hr>
<h2 id="集合类-AbstractCollection、AbstractList、AbstractSet、AbstractQueue、AbstractSequentialList、LinkedList、ArrayList、ArrayDeque、EnumSet、HashSet、LinkedHashSet、PriorityQueue、TreeSet"><a href="#集合类-AbstractCollection、AbstractList、AbstractSet、AbstractQueue、AbstractSequentialList、LinkedList、ArrayList、ArrayDeque、EnumSet、HashSet、LinkedHashSet、PriorityQueue、TreeSet" class="headerlink" title="集合类:AbstractCollection、AbstractList、AbstractSet、AbstractQueue、AbstractSequentialList、LinkedList、ArrayList、ArrayDeque、EnumSet、HashSet、LinkedHashSet、PriorityQueue、TreeSet"></a>集合类:AbstractCollection、AbstractList、AbstractSet、AbstractQueue、AbstractSequentialList、LinkedList、ArrayList、ArrayDeque、EnumSet、HashSet、LinkedHashSet、PriorityQueue、TreeSet</h2><h3 id="1-ArrayList类：（拓展了AbstractList类）（实现了List接口）（泛型类）"><a href="#1-ArrayList类：（拓展了AbstractList类）（实现了List接口）（泛型类）" class="headerlink" title="1. ArrayList类：（拓展了AbstractList类）（实现了List接口）（泛型类）"></a>1. ArrayList类：（拓展了AbstractList类）（实现了List接口）（泛型类）</h3><ol>
<li>泛型类：class ArrayList<e></e></li>
<li>可变长度数组</li>
<li>构造函数（源码）：<ol>
<li>ArrayList():空数组列表</li>
<li>ArrayList(int capacity);初始容量数组列表</li>
<li>ArrayList(Collection&lt;? extends E&gt; c);使用集合c的元素进行初始化</li>
</ol>
</li>
<li>初始化：<ol>
<li>ArrayList<class-name> list = new ArrayList<class-name>();</class-name></class-name></li>
<li>ArrayList<class-name> list = new ArrayList<class-name>(Arrays.asList(obj…))</class-name></class-name></li>
</ol>
</li>
<li>因为ArrayList实现了List接口，可以使用List的接口方法</li>
<li>列表与数组互相转换：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;ONE&quot;,&quot;TWO&quot;,&quot;THREE&quot;));//数组转列表</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		String str[] = new String[list.size()];	</span><br><span class="line">		list.toArray(str);		//列表转数组</span><br><span class="line">		System.out.println(list);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="2-LinkedList类：（拓展了AbstracSequentialList类）（实现了List、Deque、Queue接口）（泛型类）"><a href="#2-LinkedList类：（拓展了AbstracSequentialList类）（实现了List、Deque、Queue接口）（泛型类）" class="headerlink" title="2. LinkedList类：（拓展了AbstracSequentialList类）（实现了List、Deque、Queue接口）（泛型类）"></a>2. LinkedList类：（拓展了AbstracSequentialList类）（实现了List、Deque、Queue接口）（泛型类）</h3><ol>
<li>泛型类：class LinkedList<e></e></li>
<li>链表数据结构</li>
<li>构造函数（源码）：<ol>
<li>LinkedList();空链表</li>
<li>LinkedList(Collection&lt;? extends E&gt; c);使用集合c的元素进行初始化</li>
</ol>
</li>
<li>初始化：<ol>
<li>LinkedList<class-name> linklist = new LinkedList<class-name>();</class-name></class-name></li>
<li>LinkedList<class-name> linklist = new LinkedList<class-name>(Arrays.asList)</class-name></class-name></li>
</ol>
</li>
<li>因为LinkedList实现了List、Deque、Queue接口，可以使用它们的接口方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		LinkedList&lt;String&gt; linklist = new LinkedList&lt;String&gt;();</span><br><span class="line">		linklist.add(&quot;B&quot;);</span><br><span class="line">		linklist.add(&quot;C&quot;);</span><br><span class="line">		linklist.addFirst(&quot;A&quot;);</span><br><span class="line">		linklist.addLast(&quot;E&quot;);</span><br><span class="line">		linklist.add(3, &quot;D&quot;);</span><br><span class="line">		System.out.println(&quot;after add:&quot;+linklist);</span><br><span class="line">		</span><br><span class="line">		linklist.remove(&quot;B&quot;);</span><br><span class="line">		linklist.remove(3);</span><br><span class="line">		linklist.removeFirst();</span><br><span class="line">		linklist.removeLast();</span><br><span class="line">		System.out.println(&quot;after remove:&quot;+linklist);</span><br><span class="line">		</span><br><span class="line">		String a = linklist.get(0);		//通过get和set修改第1个元素</span><br><span class="line">		linklist.set(0, a + &quot;A&quot;);</span><br><span class="line">		System.out.println(&quot;after get and set:&quot;+linklist);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="3-HashSet类：（拓展了AbstractSet类）（实现了Set接口）（泛型类）（无序）"><a href="#3-HashSet类：（拓展了AbstractSet类）（实现了Set接口）（泛型类）（无序）" class="headerlink" title="3. HashSet类：（拓展了AbstractSet类）（实现了Set接口）（泛型类）（无序）"></a>3. HashSet类：（拓展了AbstractSet类）（实现了Set接口）（泛型类）（无序）</h3><ol>
<li>泛型类：class HashSet<e></e></li>
<li>创建使用哈希表存储元素的集合。散列机制。键值对。键唯一，值可以不唯一。</li>
<li>构造函数（源码）：<ol>
<li>HashSet();创建一个默认的哈希组</li>
<li>HashSet(Collection&lt;? extends E&gt; c);使用参数c的元素初始化哈希组</li>
<li>HashSet(int capacity);创建初始容量（16）</li>
<li>HashSet(int capacity,float fillRatio);初始容量，填充率（0.0-1.0).</li>
</ol>
</li>
<li>初始化：<ol>
<li>HashSet<class-name> hs = new HashSet<class-name>();</class-name></class-name></li>
</ol>
</li>
<li>实现了Set接口，可以使用Set的方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		HashSet&lt;String&gt; hashset = new HashSet&lt;String&gt;();</span><br><span class="line">		Collections.addAll(hashset, &quot;one&quot;,&quot;two&quot;,&quot;three&quot;);		//调用Collection接口的addAll方法</span><br><span class="line">		Collections.addAll(hashset, &quot;four&quot;,&quot;five&quot;,&quot;six&quot;);</span><br><span class="line">		System.out.println(hashset);	//乱序存储</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="4-LinkedHashSet类：（拓展了HashSet类）（同样实现了Set接口）（泛型类）（有序）"><a href="#4-LinkedHashSet类：（拓展了HashSet类）（同样实现了Set接口）（泛型类）（有序）" class="headerlink" title="4. LinkedHashSet类：（拓展了HashSet类）（同样实现了Set接口）（泛型类）（有序）"></a>4. LinkedHashSet类：（拓展了HashSet类）（同样实现了Set接口）（泛型类）（有序）</h3><ol>
<li>泛型类：class LinkedHashSet<e></e></li>
<li>链表中条目的顺序就是插入链表的顺序，按序存储</li>
<li>构造函数同HashSet类</li>
<li>初始化同HashSet</li>
<li>有序存储：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		LinkedHashSet&lt;String&gt; lhs = new LinkedHashSet&lt;String&gt;();</span><br><span class="line">		Collections.addAll(lhs, &quot;ONE&quot;,&quot;TWO&quot;,&quot;THREE&quot;);</span><br><span class="line">		lhs.add(&quot;FOUR&quot;);</span><br><span class="line">		lhs.add(&quot;FIVE&quot;);</span><br><span class="line">		lhs.add(&quot;SEVEN&quot;);</span><br><span class="line">		lhs.add(&quot;SIX&quot;);</span><br><span class="line">		System.out.println(lhs);	//按序存储</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="5-TreeSet类：（拓展了AbstractSet类）（实现了NavigableSet接口）（升序）（泛型类）"><a href="#5-TreeSet类：（拓展了AbstractSet类）（实现了NavigableSet接口）（升序）（泛型类）" class="headerlink" title="5. TreeSet类：（拓展了AbstractSet类）（实现了NavigableSet接口）（升序）（泛型类）"></a>5. TreeSet类：（拓展了AbstractSet类）（实现了NavigableSet接口）（升序）（泛型类）</h3><ol>
<li>泛型类：class TreeSet<e></e></li>
<li>创建使用树进行存储的组，升序存储，访问和检索速度快。大数据首选</li>
<li>构造函数（源码）：<ol>
<li>TreeSet();创建空树</li>
<li>TreeSet(Collection&lt;? extends E&gt; c);使用参数c的元素进行初始化</li>
<li>TreeSet(Comparator&lt;? super E&gt; comp);使用比较器进行存储</li>
<li>TreeSet(SortedSet<e> ss);创建包含SortedSet接口(有序）元素</e></li>
</ol>
</li>
<li>初始化：<ol>
<li>TreeSet<class-name> treeset = new TreeSet<class-name>();</class-name></class-name></li>
</ol>
</li>
<li>可以使用Set接口、SortedSet接口和Navigable接口的方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		TreeSet&lt;String&gt; treeset = new TreeSet&lt;String&gt;();</span><br><span class="line">		Collections.addAll(treeset, &quot;A&quot;,&quot;B&quot;,&quot;C&quot;);</span><br><span class="line">		treeset.add(&quot;E&quot;);</span><br><span class="line">		treeset.add(&quot;D&quot;);</span><br><span class="line">		treeset.add(&quot;F&quot;);</span><br><span class="line">		System.out.println(treeset);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果：</span><br><span class="line">[A, B, C, D, E, F]</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="6-PriorityQueue类：（拓展了AbstractQueue类）（实现了Queue接口）（使用比较器来比较存储）（泛型类）"><a href="#6-PriorityQueue类：（拓展了AbstractQueue类）（实现了Queue接口）（使用比较器来比较存储）（泛型类）" class="headerlink" title="6. PriorityQueue类：（拓展了AbstractQueue类）（实现了Queue接口）（使用比较器来比较存储）（泛型类）"></a>6. PriorityQueue类：（拓展了AbstractQueue类）（实现了Queue接口）（使用比较器来比较存储）（泛型类）</h3><ol>
<li>泛型类：class PriorityQueue<e></e></li>
<li>创建根据队列的比较器来排序存储</li>
<li>构造函数：<ol>
<li>PriorityQueue();空队列</li>
<li>PriorityQueue(int capacity);初始容量</li>
<li>PriorityQueue(Comparator&lt;? super E&gt; comp);指定一个比较器</li>
<li>PriorityQueue(int capacity,Cpmparator&lt;? super E&gt; comp);指定一个比较器，初始容量大小</li>
<li>PriorityQueue(Collection&lt;? extends E&gt; c);使用参数C的元素初始化</li>
<li>PriorityQueue(PriorityQueue&lt;? extends E&gt; c);</li>
<li>PriorityQueue(SortedSet&lt;? extends E&gt; c);</li>
</ol>
</li>
<li>初始化：<ol>
<li>PriorityQueue<class-name> prq = new PriorityQueue<class-name>();</class-name></class-name></li>
</ol>
</li>
<li>可以使用Deque的接口方法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		PriorityQueue&lt;String&gt; prq = new PriorityQueue&lt;String&gt;();</span><br><span class="line">		Collections.addAll(prq, &quot;ONE&quot;,&quot;TWO&quot;,&quot;THREE&quot;);</span><br><span class="line">		prq.add(&quot;FOUR&quot;);</span><br><span class="line">		prq.add(&quot;SIX&quot;);</span><br><span class="line">		prq.add(&quot;FIVE&quot;);</span><br><span class="line">		</span><br><span class="line">		//Deque接口的方法</span><br><span class="line">		System.out.println(prq.element());	//获取头部元素</span><br><span class="line">		System.out.println(prq.peek());		//</span><br><span class="line">		</span><br><span class="line">		System.out.println(prq.poll());		//获取头部元素并删除</span><br><span class="line">		System.out.println(prq.remove());	//FIVE被移除后，头部元素变成FOUR,获取后移除</span><br><span class="line">		System.out.println(prq);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="7-ArrayDeque类：（拓展了AbstractCollection类）（实现了Deque接口）（动态数组）（无容量限制）（泛型类）"><a href="#7-ArrayDeque类：（拓展了AbstractCollection类）（实现了Deque接口）（动态数组）（无容量限制）（泛型类）" class="headerlink" title="7. ArrayDeque类：（拓展了AbstractCollection类）（实现了Deque接口）（动态数组）（无容量限制）（泛型类）"></a>7. ArrayDeque类：（拓展了AbstractCollection类）（实现了Deque接口）（动态数组）（无容量限制）（泛型类）</h3><ol>
<li>泛型类：class ArrayDeque<e></e></li>
<li>动态数组，无容量限制</li>
<li>构造函数：<ol>
<li>ArrayDeque();空数组</li>
<li>ArrayDeque(Collection&lt;? extends E&gt; c);使用参数c的元素初始化</li>
<li>ArrayDeque(int capacity);初始容量大小</li>
</ol>
</li>
<li>初始化：<ol>
<li>ArrayDeque<class-name> ad = new ArrayDeque<class-name>();</class-name></class-name></li>
</ol>
</li>
<li>可以使用Queue和Deque接口方法：<ol>
<li>Queue：<ol>
<li>element()\peek():获取头部</li>
<li>pool()\remove():获取头部并移除</li>
</ol>
</li>
<li>Deque：<ol>
<li>peekFirst()\peekLast():获取头部\尾部</li>
<li>pollFirst()\removeFirst()/pollLast()\removeLast():获取头部、尾部并移除</li>
<li>push(Obj obj):添加到头部</li>
<li>pop();移除头部<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		ArrayDeque&lt;String&gt; ad = new ArrayDeque&lt;String&gt;();</span><br><span class="line">		Collections.addAll(ad, &quot;ONE&quot;,&quot;TWO&quot;,&quot;THREE&quot;);</span><br><span class="line">		ad.add(&quot;FOUR&quot;);</span><br><span class="line">		ad.add(&quot;FIVE&quot;);</span><br><span class="line">		System.out.println(ad);</span><br><span class="line">		</span><br><span class="line">		//Queue接口方法</span><br><span class="line">		ad.element();</span><br><span class="line">		ad.peek();</span><br><span class="line">		//Deque接口方法</span><br><span class="line">		ad.peekFirst();</span><br><span class="line">		ad.peekLast();</span><br><span class="line">		ad.pollFirst();	//获取并移除第一个元素，ONE OUT</span><br><span class="line">		ad.pollLast();	//获取并移除最后一个元素，FIVE OUT</span><br><span class="line">		ad.removeFirst();</span><br><span class="line">		ad.removeLast();</span><br><span class="line">		ad.push(&quot;SIX&quot;);		//添加到头部</span><br><span class="line">		System.out.println(ad);</span><br><span class="line">		ad.pop();	//移除头部</span><br><span class="line">		System.out.println(ad);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="1-迭代器Iterator：（适用于所有集合类）（遍历）（获取或移除元素）（泛型接口）"><a href="#1-迭代器Iterator：（适用于所有集合类）（遍历）（获取或移除元素）（泛型接口）" class="headerlink" title="1. 迭代器Iterator：（适用于所有集合类）（遍历）（获取或移除元素）（泛型接口）"></a>1. 迭代器Iterator：（适用于所有集合类）（遍历）（获取或移除元素）（泛型接口）</h3><ol>
<li>泛型接口：interface Iterator<e></e></li>
<li>获取或移除元素</li>
<li>常用方法：<ol>
<li>boolean hasNext();判断后面是否还有元素</li>
<li>E next();获取下一个元素</li>
<li>void remove();移除当前元素，一般配合next()使用</li>
</ol>
</li>
<li>实现类该接口的集合类：所有集合类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void  main(String args[]) &#123;</span><br><span class="line">		ArrayList&lt;String&gt; iter = new ArrayList&lt;String&gt;();</span><br><span class="line">		Collections.addAll(iter, &quot;jdk&quot;,&quot;jre&quot;,&quot;wjh&quot;,&quot;javac&quot;);</span><br><span class="line">		System.out.println(iter);</span><br><span class="line"></span><br><span class="line">		Iterator&lt;String&gt; iterlist = iter.iterator();</span><br><span class="line">		while(iterlist.hasNext()) &#123;</span><br><span class="line">			System.out.println(iterlist.next());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h3 id="2-ListIterator：（拓展自Iterator接口）（实现了List接口的集合）（向前向后）（修改元素）"><a href="#2-ListIterator：（拓展自Iterator接口）（实现了List接口的集合）（向前向后）（修改元素）" class="headerlink" title="2. ListIterator：（拓展自Iterator接口）（实现了List接口的集合）（向前向后）（修改元素）"></a>2. ListIterator：（拓展自Iterator接口）（实现了List接口的集合）（向前向后）（修改元素）</h3><ol>
<li>泛型接口：interface ListIterator<e></e></li>
<li>双向遍历、修改元素</li>
<li>常用方法：<ol>
<li>boolean hasNext();</li>
<li>boolean hasPrevious();倒序</li>
<li>E next();获取下一个元素</li>
<li>void add(E obj);将obj插入到当前next()的元素之前</li>
<li>void remove();移除</li>
<li>void set(E obj);将obj赋值给当前next()或previous()方法调用最后返回的元素</li>
</ol>
</li>
<li>实现了该接口的集合类：所有集合类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		ArrayList&lt;String&gt; listiter = new ArrayList&lt;String&gt;(Arrays.asList(&quot;ONE&quot;,&quot;TWO&quot;,&quot;THREE&quot;));</span><br><span class="line">		ListIterator&lt;String&gt; iter = listiter.listIterator();</span><br><span class="line">		while(iter.hasNext()) &#123;</span><br><span class="line">			System.out.println(iter.next());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		while(iter.hasPrevious()) &#123;		//倒序</span><br><span class="line">			System.out.println(iter.previous());	//倒序</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="使用for-each迭代集合"><a href="#使用for-each迭代集合" class="headerlink" title="使用for-each迭代集合"></a>使用for-each迭代集合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		ArrayList&lt;String&gt; listiter = new ArrayList&lt;String&gt;(Arrays.asList(&quot;ONE&quot;,&quot;TWO&quot;,&quot;THREE&quot;));</span><br><span class="line">		for(String s:listiter)</span><br><span class="line">			System.out.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="集合中也可以存储自定义的类"><a href="#集合中也可以存储自定义的类" class="headerlink" title="集合中也可以存储自定义的类"></a>集合中也可以存储自定义的类</h2><p>在实例化泛型集合类时，类型参数E可以是自定义的类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Book&#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private	String author;</span><br><span class="line">	private String type;</span><br><span class="line">	private double price;</span><br><span class="line">	</span><br><span class="line">	Book(String n,String a,String t,double p)&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		author = a;</span><br><span class="line">		type = t;</span><br><span class="line">		price = p;</span><br><span class="line">	&#125;</span><br><span class="line">	public String GetInfomation() &#123;</span><br><span class="line">		return &quot;name:&quot;+name+&quot;,author:&quot;+author+&quot;,type:&quot;+type+&quot;,price:&quot;+price;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		LinkedList&lt;Book&gt; book = new LinkedList&lt;Book&gt;();</span><br><span class="line">		book.add(new Book(&quot;红楼梦&quot;,&quot;曹雪芹&quot;,&quot;文学小说&quot;,50.5));</span><br><span class="line">		book.add(new Book(&quot;挪威的森林&quot;,&quot;村上春树&quot;,&quot;小说&quot;,34.5));</span><br><span class="line">		book.add(new Book(&quot;我是猫&quot;,&quot;夏目漱石&quot;,&quot;小说&quot;,29.5));</span><br><span class="line">		for(Book element:book)</span><br><span class="line">			System.out.println(element.GetInfomation());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="映射（Map）"><a href="#映射（Map）" class="headerlink" title="映射（Map）"></a>映射（Map）</h1><h2 id="映射接口"><a href="#映射接口" class="headerlink" title="映射接口"></a>映射接口</h2><h3 id="1-Map接口（键值对，以键取值，键唯一，值不唯一）（泛型接口）"><a href="#1-Map接口（键值对，以键取值，键唯一，值不唯一）（泛型接口）" class="headerlink" title="1. Map接口（键值对，以键取值，键唯一，值不唯一）（泛型接口）"></a>1. Map接口（键值对，以键取值，键唯一，值不唯一）（泛型接口）</h3><ol>
<li>泛型接口：interface Map(K,V);K为key的类型，V为value类型</li>
<li>常用方法：<ol>
<li>V put(K key,V value);追加一个键值对</li>
<li>V get(Obj key);通过键得到值</li>
<li>void clear();清空Map中的数据</li>
<li>boolean containsKey(Obj key);判断该键是否在Map中</li>
<li>boolean containsValue(Obj value);判断该值是否在Map中</li>
<li>V replace(K key,V value);替换指定键的值</li>
<li>V remove(Obj key);删除目标键的条目</li>
</ol>
</li>
<li>实现了Map接口的集合类：<ol>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
</ol>
</li>
<li>遍历Map：<ol>
<li>keySet():返回Set,先取键再取值</li>
<li>values():返回Collection，直接取值</li>
</ol>
</li>
</ol>
<hr>
<h3 id="2-SortedMap接口（升序）（泛型接口）"><a href="#2-SortedMap接口（升序）（泛型接口）" class="headerlink" title="2. SortedMap接口（升序）（泛型接口）"></a>2. SortedMap接口（升序）（泛型接口）</h3><ol>
<li>泛型接口：interface SortedMap&lt;K,V&gt;;K为键类型，V为值类型</li>
<li>常用方法：<ol>
<li>V put(K key,V value);追加一个键值对</li>
<li>V get(Obj key);通过键得到值</li>
<li>void clear();清空Map中的数据</li>
<li>boolean containsKey(Obj key);判断该键是否在Map中</li>
<li>boolean containsValue(Obj value);判断该值是否在Map中</li>
<li>V replace(K key,V value);替换指定键的值</li>
<li>V remove(Obj key);删除目标键的条目</li>
<li>K firstKey();返回第一个键</li>
<li>K lastKey();返回最后一个键</li>
</ol>
</li>
<li>实现了SortedMap接口的集合类：<ol>
<li>HashMap</li>
<li>LinkedHashMap</li>
<li>TreeMap</li>
</ol>
</li>
</ol>
<hr>
<h2 id="映射类：AbstractMap、EnumMap、HashMap、TreeMap、WeakHashMap、LinkedHashMap、IdentityHashMap"><a href="#映射类：AbstractMap、EnumMap、HashMap、TreeMap、WeakHashMap、LinkedHashMap、IdentityHashMap" class="headerlink" title="映射类：AbstractMap、EnumMap、HashMap、TreeMap、WeakHashMap、LinkedHashMap、IdentityHashMap"></a>映射类：AbstractMap、EnumMap、HashMap、TreeMap、WeakHashMap、LinkedHashMap、IdentityHashMap</h2><h3 id="1-映射视图（实现了Collection及其子接口）"><a href="#1-映射视图（实现了Collection及其子接口）" class="headerlink" title="1. 映射视图（实现了Collection及其子接口）"></a>1. 映射视图（实现了Collection及其子接口）</h3><ol>
<li>映射是键值对，而非集合。不过映射的视图是实现了Collection接口的对象</li>
<li>三种视图：<ol>
<li>键集：Set<k> key-obj = map-obj.KeySet();</k></li>
<li>值集合：Collection<v> value-obj = map-obj.values();</v></li>
<li>键值对集合：Set&lt;Map.Entry&lt;K,V&gt;&gt; k-v-obj = map-obj.entrySet();</li>
</ol>
</li>
<li>分析三种视图的功能：<ol>
<li>Set<k> key-obj = map-obj.KeySet():返回映射中所有键的集合视图。只能删除键，不能添加：</k></li>
<li>Collection<v> value-obj = map-obj.values();返回映射的值视图，只能删除值，不能添加。</v></li>
<li>Set&lt;Map.Entry&lt;K,V&gt;&gt; k-v-obj = map-obj.entrySet();返回键值对视图，只能删除键或值，不能添加<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		HashMap&lt;String,Double&gt; account = new HashMap&lt;String,Double&gt;();</span><br><span class="line">		account.put(&quot;wjh&quot;,35993.3);</span><br><span class="line">		account.put(&quot;llh&quot;,35555.6);	//Map接口使用put存入数据</span><br><span class="line">		account.put(&quot;sjz&quot;, 35663.4);</span><br><span class="line">		</span><br><span class="line">		Set&lt;String&gt; keyobj = account.keySet();	//返回键视图</span><br><span class="line">		keyobj.remove(&quot;wjh&quot;);		//只能删除键</span><br><span class="line">		for(String name:keyobj)</span><br><span class="line">			System.out.println(name);</span><br><span class="line">		</span><br><span class="line">		Collection&lt;Double&gt; valueobj = account.values();	//返回值视图</span><br><span class="line">		valueobj.remove(35993.3);		//只能删除值</span><br><span class="line">		for(Double nums:valueobj)</span><br><span class="line">			System.out.println(nums);</span><br><span class="line">		</span><br><span class="line">		Set&lt;Map.Entry&lt;String, Double&gt;&gt; KeyValueObj = account.entrySet();		//返回键值对视图</span><br><span class="line">//		KeyValueObj.remove(35993.3);</span><br><span class="line">		KeyValueObj.remove(&quot;wjh&quot;);			//只能删除键或值</span><br><span class="line">		for(Map.Entry&lt;String, Double&gt; information:KeyValueObj) &#123;	</span><br><span class="line">			System.out.println(information.getKey()+&quot;:&quot;+information.getValue());	//getKey/getValue</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<hr>
<h3 id="2-HashMap类：（拓展了AbstractMap类）（实现了Map接口）（使用哈希表存储映射）（泛型类）"><a href="#2-HashMap类：（拓展了AbstractMap类）（实现了Map接口）（使用哈希表存储映射）（泛型类）" class="headerlink" title="2. HashMap类：（拓展了AbstractMap类）（实现了Map接口）（使用哈希表存储映射）（泛型类）"></a>2. HashMap类：（拓展了AbstractMap类）（实现了Map接口）（使用哈希表存储映射）（泛型类）</h3><ol>
<li>泛型类：class HashMap(K,V)</li>
<li>使用哈希表存储映射(键值对)，用于大集合</li>
<li>构造函数：<ol>
<li>HashMap();空哈希映射</li>
<li>HashMap(Map&lt;? extends K,? extends V&gt; m);使用m中的元素初始化哈希映射</li>
<li>HashMap(int capacity);初始容量</li>
<li>HashMap(int capacity,float fillRatio);capacity*fillRatio</li>
</ol>
</li>
<li>常用方法：<ol>
<li>V put(K key,V value);追加一个键值对</li>
<li>V get(Obj key);通过键得到值</li>
<li>void clear();清空Map中的数据</li>
<li>boolean containsKey(Obj key);判断该键是否在Map中</li>
<li>boolean containsValue(Obj value);判断该值是否在Map中</li>
<li>V replace(K key,V value);替换指定键的值</li>
<li>V remove(Obj key);删除目标键的条目</li>
</ol>
</li>
<li>实例化：<ol>
<li>HashMap&lt;K,V&gt; hashmap = new HashMap&lt;K,V&gt;();</li>
<li>只存键：Set<k> keyobj = hashmap.keySet();</k></li>
<li>只存值：Collection<v> valueobj = hashmap.values();</v></li>
<li>存键值对：Set&lt;Map.Entry&lt;K,V&gt;&gt; key-value-obj = hashmap.entrySet();<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		HashMap&lt;String,Double&gt; information = new HashMap&lt;String,Double&gt;();</span><br><span class="line">		information.put(&quot;wjh&quot;, 39844.3);</span><br><span class="line">		information.put(&quot;llh&quot;, 32324.4);</span><br><span class="line">		Set&lt;Map.Entry&lt;String,Double&gt;&gt; info = information.entrySet();</span><br><span class="line">		for(Map.Entry&lt;String, Double&gt; informations:info)</span><br><span class="line">			System.out.println(&quot;Name:&quot;+informations.getKey()+&quot;,Balacne:&quot;+informations.getValue());</span><br><span class="line">		</span><br><span class="line">		information.put(&quot;wjh&quot;,information.get(&quot;wjh&quot;)+1000);		//值增加</span><br><span class="line">		System.out.println(information.get(&quot;wjh&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<hr>
<h3 id="3-TreeMap类：（拓展了AbstractMap类）（实现了NavigableMap接口）（映射存储在树结构中）（有序键值对）（快速检索）（升序存储）（泛型类）"><a href="#3-TreeMap类：（拓展了AbstractMap类）（实现了NavigableMap接口）（映射存储在树结构中）（有序键值对）（快速检索）（升序存储）（泛型类）" class="headerlink" title="3. TreeMap类：（拓展了AbstractMap类）（实现了NavigableMap接口）（映射存储在树结构中）（有序键值对）（快速检索）（升序存储）（泛型类）"></a>3. TreeMap类：（拓展了AbstractMap类）（实现了NavigableMap接口）（映射存储在树结构中）（有序键值对）（快速检索）（升序存储）（泛型类）</h3><ol>
<li>泛型类：class TreeMap(K,V)</li>
<li>使用树结构存储映射，有序键值对，升序存储，快速检索</li>
<li>构造函数：<ol>
<li>TreeMap();空的树映射</li>
<li>TreeMap(Comparator&lt;? super K&gt; comp);有序键值对，使用比较器comp进行排序</li>
<li>TreeMap(Map&lt;? extends K,? extends V&gt; m);使用m条目初始化映射</li>
<li>TreeMap(SortedMap&lt;K,? extends V&gt; sm);使用sm条目初始化映射</li>
</ol>
</li>
<li>常用方法：<ol>
<li>V put(K key,V value);追加一个键值对</li>
<li>V get(Obj key);通过键得到值</li>
<li>void clear();清空Map中的数据</li>
<li>boolean containsKey(Obj key);判断该键是否在Map中</li>
<li>boolean containsValue(Obj value);判断该值是否在Map中</li>
<li>V replace(K key,V value);替换指定键的值</li>
<li>V remove(Obj key);删除目标键的条目</li>
<li>K firstKey();返回第一个键</li>
<li>K lastKey();返回最后一个键</li>
</ol>
</li>
<li>实例化：<ol>
<li>TreeMap&lt;K,V&gt; treemap = new TreeMap&lt;K,V&gt;();</li>
<li>只存键：Set<k> keyobj = treemap.keySet();</k></li>
<li>只存值：Collection<v> valueobj = treemap.values();</v></li>
<li>存键值对：Set&lt;Map.Entry&lt;K,V&gt;&gt; key-value-obj = treemap.entrySet();<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		TreeMap&lt;String,String&gt; treemap = new TreeMap&lt;String,String&gt;();</span><br><span class="line">		treemap.put(&quot;红楼梦&quot;, &quot;曹雪芹&quot;);</span><br><span class="line">		treemap.put(&quot;挪威的森林&quot;, &quot;村上春树&quot;);</span><br><span class="line">		treemap.put(&quot;百年孤独&quot;,&quot;马尔克斯&quot;);</span><br><span class="line">		treemap.put(&quot;我是猫&quot;, &quot;川端康成&quot;);</span><br><span class="line">		Set&lt;Map.Entry&lt;String, String&gt;&gt; book = treemap.entrySet();</span><br><span class="line">		for(Map.Entry&lt;String, String&gt; books:book)</span><br><span class="line">			System.out.println(&quot;Name:&quot;+books.getKey()+&quot;,Author:&quot;+books.getValue());</span><br><span class="line">		System.out.println();</span><br><span class="line">		treemap.replace(&quot;我是猫&quot;, &quot;夏目漱石&quot;);</span><br><span class="line">		for(Map.Entry&lt;String, String&gt; books:book)</span><br><span class="line">			System.out.println(&quot;Name:&quot;+books.getKey()+&quot;,Author:&quot;+books.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<hr>
<h3 id="4-LinkedHashMap类：（拓展了HashMap类）（按插入顺序迭代映射）（泛型类）"><a href="#4-LinkedHashMap类：（拓展了HashMap类）（按插入顺序迭代映射）（泛型类）" class="headerlink" title="4. LinkedHashMap类：（拓展了HashMap类）（按插入顺序迭代映射）（泛型类）"></a>4. LinkedHashMap类：（拓展了HashMap类）（按插入顺序迭代映射）（泛型类）</h3><ol>
<li>泛型类：class LinkedHashMap&lt;K,V&gt;</li>
<li>以插入条目的顺序维护条目链表，按照插入顺序迭代映射</li>
<li>构造函数：<ol>
<li>LinkedHashMap();构造默认LinkedHashMap</li>
<li>LinkedHashMap(Map&lt;? extends K,? extends V&gt; m);使用m中的元素初始化LinkedHashMap</li>
<li>LinkedHashMap(int capacity);初始容量</li>
<li>LinkedHashMap(int capacity,float fillRatio);初始容量*Ratio</li>
</ol>
</li>
<li>常用方法：<ol>
<li>V put(K key,V value);追加一个键值对</li>
<li>V get(Obj key);通过键得到值</li>
<li>void clear();清空Map中的数据</li>
<li>boolean containsKey(Obj key);判断该键是否在Map中</li>
<li>boolean containsValue(Obj value);判断该值是否在Map中</li>
<li>V replace(K key,V value);替换指定键的值</li>
<li>V remove(Obj key);删除目标键的条目</li>
</ol>
</li>
<li>初始化：<ol>
<li>LinkedHashMap&lt;K,V&gt; linkedhashmap = new LinkedHashMap&lt;K,V&gt;();</li>
<li>只存键：Set<k> keyobj = linkedhashmap.keySet();</k></li>
<li>只存值：Collection<v> valueobj = linkedhashmap.values();</v></li>
<li>存键值对：Set&lt;Map.Entry&lt;K,V&gt;&gt; key-value-obj = linkedhashmap.entrySet();<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		LinkedHashMap&lt;String,Double&gt; lhm = new LinkedHashMap&lt;String,Double&gt;();</span><br><span class="line">		lhm.put(&quot;A&quot;, 100.0);</span><br><span class="line">		lhm.put(&quot;c&quot;, 150.5);</span><br><span class="line">		lhm.put(&quot;b&quot;,120.0);		//按顺序存入</span><br><span class="line">		Set&lt;Map.Entry&lt;String, Double&gt;&gt; set = lhm.entrySet();</span><br><span class="line">		for(Map.Entry&lt;String, Double&gt; a :set)</span><br><span class="line">			System.out.println(a.getKey()+&quot;,&quot;+a.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<hr>
<h2 id="比较器Comparator：（TreeSet和TreeMap-（有序存储）（自然顺序排列）（泛型接口）"><a href="#比较器Comparator：（TreeSet和TreeMap-（有序存储）（自然顺序排列）（泛型接口）" class="headerlink" title="比较器Comparator：（TreeSet和TreeMap)（有序存储）（自然顺序排列）（泛型接口）"></a>比较器Comparator：（TreeSet和TreeMap)（有序存储）（自然顺序排列）（泛型接口）</h2><ol>
<li>泛型接口：interface Comparator<t></t></li>
<li>能对元素按自然顺序进行排序</li>
<li>常用方法：<ol>
<li>compare():int compare(T ob1,T ob2);比较两个元素</li>
<li>equals():boolean equals(Obj obj):判断obj是否为比较器</li>
</ol>
</li>
<li>使用比较器：<ol>
<li>定义一个实现了比较器方法：class name implements Comparator<t>{}</t></li>
<li>创建集合类时，传入实现类作为参数：TreeSet<t> obj = new TreeSet<t>(new name);</t></t></li>
</ol>
</li>
<li>TreeSet倒序存储：<br>使用自定义比较器：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Compare implements Comparator&lt;Double&gt;&#123;</span><br><span class="line">	public int compare(double a,double b) &#123;		//自定义比较器</span><br><span class="line">		return b.compareTo(a);		//b比a,默认是a比b</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		TreeSet&lt;Double&gt; ts = new TreeSet&lt;Double&gt;(new Compare());</span><br><span class="line">		ts.add(97.5);</span><br><span class="line">		ts.add(76.4);</span><br><span class="line">		ts.add(75.5);</span><br><span class="line">		for(Double nums:ts)</span><br><span class="line">			System.out.println(&quot;score:&quot;+nums);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>lambda表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		TreeSet&lt;Double&gt; ts = new TreeSet&lt;Double&gt;((a,b)-&gt;b.compareTo(a));	//lambda表达式。a,b作为参数传入compareTo方法</span><br><span class="line">		ts.add(97.5);</span><br><span class="line">		ts.add(76.4);</span><br><span class="line">		ts.add(75.5);</span><br><span class="line">		for(Double nums:ts)</span><br><span class="line">			System.out.println(&quot;score:&quot;+nums);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中文也可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		TreeSet&lt;String&gt; ts = new TreeSet&lt;String&gt;((a,b) -&gt; a.compareTo(b));</span><br><span class="line">		Collections.addAll(ts, &quot;挪威的森林&quot;,&quot;我是猫&quot;,&quot;百年孤独&quot;);</span><br><span class="line">		for(String book:ts)</span><br><span class="line">			System.out.println(&quot;Name:&quot;+book);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="集合算法"><a href="#集合算法" class="headerlink" title="集合算法"></a>集合算法</h2><ol>
<li><p>查找集合中最值：Collections.min()/max()</p>
<ol>
<li><p>集合类使用CollectionS.min/max:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; ll = new LinkedList&lt;Integer&gt;();</span><br><span class="line">ll.add(-122);</span><br><span class="line">ll.add(123);</span><br><span class="line">ll.add(-2);</span><br><span class="line">ll.add(23);</span><br><span class="line">System.out.println(Collections.min(ll));</span><br><span class="line">System.out.println(Collections.max(ll));</span><br></pre></td></tr></table></figure>
</li>
<li><p>映射类使用Collections.min/max:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;String,String&gt; tm = new TreeMap&lt;String,String&gt;();</span><br><span class="line">tm.put(&quot;Dream of the Red Chamber&quot;, &quot;Cao Xueqin&quot;);</span><br><span class="line">tm.put(&quot;I am a cat&quot;, &quot;Natsume Soseki&quot;);</span><br><span class="line">tm.put(&quot;One hundred years of loneliness&quot;,&quot;Marquez&quot;);</span><br><span class="line">tm.put(&quot;The forest in Norway&quot;, &quot;Haruki Murakami&quot;);</span><br><span class="line">System.out.println(Collections.min(tm.keySet()));		//keySet存入键，查找最小的键</span><br><span class="line">System.out.println(Collections.max(tm.values()));	//values()存入值，查找最大的值</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>排序：升序:Collections.sort();降序：Collections.reverse-Order()；混乱排序：Collections.shuffle();</p>
<ol>
<li><p>升序：<br>//按工资对员工列表排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		TreeMap&lt;String,Double&gt; tm = new TreeMap&lt;String,Double&gt;();</span><br><span class="line">		tm.put(&quot;wwe&quot;,102.3);</span><br><span class="line">		tm.put(&quot;wig&quot;,23.534);</span><br><span class="line">		tm.put(&quot;weit&quot;, -239.3);</span><br><span class="line">		ArrayList&lt;Map.Entry&lt;String, Double&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,Double&gt;&gt;(tm.entrySet());</span><br><span class="line">		Collections.sort(list, new Comparator&lt;Map.Entry&lt;String, Double&gt;&gt;()&#123;</span><br><span class="line">			public int compare(Map.Entry&lt;String, Double&gt; ob1,Map.Entry&lt;String, Double&gt; ob2) &#123;</span><br><span class="line">				if(ob1.getValue()&gt;=ob2.getValue())</span><br><span class="line">					return ob2.getValue().compareTo(ob2.getValue());</span><br><span class="line">					else</span><br><span class="line">						return ob1.getValue().compareTo(ob2.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		for(Map.Entry&lt;String, Double&gt; e:list)</span><br><span class="line">			System.out.println(e.getKey()+&quot;:&quot;+e.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义比较器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class GetSalary implements Comparator&lt;String&gt;&#123;</span><br><span class="line">	Map&lt;String,Double&gt; hm;		//创建一个Map接口的引用</span><br><span class="line">	GetSalary(Map&lt;String,Double&gt; hm)&#123;</span><br><span class="line">		this.hm = hm;</span><br><span class="line">	&#125;</span><br><span class="line">	public int compare(String ob1,String ob2) &#123;</span><br><span class="line">		if(hm.get(ob1)&gt;=hm.get(ob2)) &#123;		//获取该键的值</span><br><span class="line">			return hm.get(ob2).compareTo(hm.get(ob1));	//返回ob2</span><br><span class="line">		&#125;else</span><br><span class="line">			return hm.get(ob1).compareTo(hm.get(ob2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		HashMap&lt;String,Double&gt; hm = new HashMap&lt;String,Double&gt;();</span><br><span class="line">		TreeMap&lt;String,Double&gt; map = new TreeMap&lt;String,Double&gt;(new GetSalary(hm));</span><br><span class="line">		hm.put(&quot;asd&quot;,123.3);</span><br><span class="line">		hm.put(&quot;as2d&quot;,13.3);</span><br><span class="line">		hm.put(&quot;aswdd&quot;,12.3);</span><br><span class="line">		map.putAll(hm);</span><br><span class="line">		System.out.println(map);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>降序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		TreeMap&lt;String,Double&gt; tm = new TreeMap&lt;String,Double&gt;();</span><br><span class="line">		tm.put(&quot;wwe&quot;,102.3);</span><br><span class="line">		tm.put(&quot;wig&quot;,23.534);</span><br><span class="line">		tm.put(&quot;weit&quot;, -239.3);</span><br><span class="line">		ArrayList&lt;Map.Entry&lt;String, Double&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,Double&gt;&gt;(tm.entrySet());</span><br><span class="line">		Collections.reverseOrder(new Comparator&lt;Map.Entry&lt;String, Double&gt;&gt;()&#123;</span><br><span class="line">			public int compare(Map.Entry&lt;String, Double&gt; ob1,Map.Entry&lt;String, Double&gt; ob2) &#123;</span><br><span class="line">				if(ob1.getValue()&gt;=ob2.getValue())</span><br><span class="line">					return ob2.getValue().compareTo(ob2.getValue());</span><br><span class="line">					else</span><br><span class="line">						return ob1.getValue().compareTo(ob2.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		for(Map.Entry&lt;String, Double&gt; e:list)</span><br><span class="line">			System.out.println(e.getKey()+&quot;:&quot;+e.getValue());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>随机排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		LinkedList&lt;Integer&gt; ll = new LinkedList&lt;Integer&gt;();</span><br><span class="line">		for(int i=0;i&lt;10;i++)</span><br><span class="line">			ll.add(i);</span><br><span class="line">		Collections.shuffle(ll);	//随机排序存储</span><br><span class="line">		for(Integer shuf:ll)		</span><br><span class="line">			System.out.println(shuf);</span><br><span class="line">		System.out.println();</span><br><span class="line">		Collections.sort(ll);		//按升序存储</span><br><span class="line">		for(Integer sort:ll)</span><br><span class="line">			System.out.println(sort);</span><br><span class="line">		System.out.println();</span><br><span class="line">		Collections.reverse(ll);		//倒序存储</span><br><span class="line">		for(Integer reverse:ll)</span><br><span class="line">			System.out.println(reverse);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>二分查找：Collections.binarySearch();前提是集合必须是已经排序好的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		ArrayList&lt;Double&gt; al = new ArrayList&lt;Double&gt;(Arrays.asList(12.3,2.12,321.4,122.4));</span><br><span class="line">		Collections.sort(al);		//必须先排序</span><br><span class="line">		</span><br><span class="line">		System.out.println(Collections.binarySearch(al, 12.32));	//1代表查找到，-3代表没查找到</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制元素：Collections.copy(list1,list2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		ArrayList&lt;Double&gt; al = new ArrayList&lt;Double&gt;(Arrays.asList(12.3,23.4,33.5,335.5));</span><br><span class="line">		</span><br><span class="line">		Collections.sort(al);		//必须先排序</span><br><span class="line">		System.out.println(Collections.binarySearch(al, 12.32));	//1代表查找到，-3代表没查找到</span><br><span class="line">		System.out.println(al);</span><br><span class="line">		</span><br><span class="line">		ArrayList&lt;Double&gt; list = new ArrayList&lt;Double&gt;();</span><br><span class="line">		Collections.addAll(list, new Double[al.size()]);	//创建一个长度为al.size的list集合</span><br><span class="line">		Collections.copy(list, al);		//将al的元素复制到list</span><br><span class="line">		list.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h2 id="Arrays类：（数组操作方法）（连接集合与数组）"><a href="#Arrays类：（数组操作方法）（连接集合与数组）" class="headerlink" title="Arrays类：（数组操作方法）（连接集合与数组）"></a>Arrays类：（数组操作方法）（连接集合与数组）</h2><h3 id="1-asList方法："><a href="#1-asList方法：" class="headerlink" title="1. asList方法："></a>1. asList方法：</h3><p>static <t> List as(T…array)</t></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(&quot;ONE&quot;,&quot;TWO&quot;,&quot;THREE&quot;));//数组转列表</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		String str[] = new String[list.size()];	</span><br><span class="line">		list.toArray(str);		//列表转数组</span><br><span class="line">		System.out.println(list);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-binarySearch方法：二分查找"><a href="#2-binarySearch方法：二分查找" class="headerlink" title="2. binarySearch方法：二分查找"></a>2. binarySearch方法：二分查找</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">	public static void main(String args[]) &#123;</span><br><span class="line">		ArrayList&lt;Double&gt; al = new ArrayList&lt;Double&gt;(Arrays.asList(12.3,23.4,33.5,335.5));</span><br><span class="line">		</span><br><span class="line">		Collections.sort(al);		//必须先排序</span><br><span class="line">		System.out.println(Collections.binarySearch(al, 12.32));	//1代表查找到，-3代表没查找到</span><br><span class="line">		System.out.println(al);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://yoursite.com">ks-39</a>
            <p>原文链接：<a href="http://yoursite.com/2019/09/15/JavaSe/Java学习笔记(Day 12：Java.util集合框架)/">http://yoursite.com/2019/09/15/JavaSe/Java学习笔记(Day 12：Java.util集合框架)/</a>
            <p>发表日期：<a href="http://yoursite.com/2019/09/15/JavaSe/Java学习笔记(Day 12：Java.util集合框架)/">September 15th 2019, 1:26:14 pm</a>
            <p>更新日期：<a href="http://yoursite.com/2019/09/15/JavaSe/Java学习笔记(Day 12：Java.util集合框架)/">February 13th 2020, 11:30:10 pm</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2019/09/17/JavaSe/Java学习笔记(Day 13Java.IO)/" title= "Java学习笔记(Day 13:Java.IO)">
                    <div class="nextTitle">Java学习笔记(Day 13:Java.IO)</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2019/09/10/JavaSe/Java学习笔记(Day 11：lambda表达式)/" title= "Java学习笔记(Day 11：lambda表达式)">
                    <div class="prevTitle">Java学习笔记(Day 11：lambda表达式)</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:842189357@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/ks-39" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#P506-P580"><span class="toc-number">1.</span> <span class="toc-text">P506-P580</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结："><span class="toc-number">2.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合接口：Collection、List、Set、SortedSet、NavigableSet、Queue。"><span class="toc-number">3.</span> <span class="toc-text">集合接口：Collection、List、Set、SortedSet、NavigableSet、Queue。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Collection接口：（所有集合类都实现了该接口）（泛型接口）（无序集合）"><span class="toc-number">3.1.</span> <span class="toc-text">1. Collection接口：（所有集合类都实现了该接口）（泛型接口）（无序集合）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-List接口：（继承自Collection）（有序集合）（泛型接口）"><span class="toc-number">3.2.</span> <span class="toc-text">2. List接口：（继承自Collection）（有序集合）（泛型接口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Set接口：（继承自Collection）（无序集合）（泛型接口）"><span class="toc-number">3.3.</span> <span class="toc-text">3. Set接口：（继承自Collection）（无序集合）（泛型接口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-SortedSet接口：（继承自Set接口）（升序存储）（泛型接口）"><span class="toc-number">3.4.</span> <span class="toc-text">4. SortedSet接口：（继承自Set接口）（升序存储）（泛型接口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Queue接口：（继承自Collection）（队列）（先进先出）（泛型接口）"><span class="toc-number">3.5.</span> <span class="toc-text">5. Queue接口：（继承自Collection）（队列）（先进先出）（泛型接口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Deque接口：（继承自Queue）（双端队列）（先进先出）（后进先出）（泛型接口）"><span class="toc-number">3.6.</span> <span class="toc-text">6. Deque接口：（继承自Queue）（双端队列）（先进先出）（后进先出）（泛型接口）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合类-AbstractCollection、AbstractList、AbstractSet、AbstractQueue、AbstractSequentialList、LinkedList、ArrayList、ArrayDeque、EnumSet、HashSet、LinkedHashSet、PriorityQueue、TreeSet"><span class="toc-number">4.</span> <span class="toc-text">集合类:AbstractCollection、AbstractList、AbstractSet、AbstractQueue、AbstractSequentialList、LinkedList、ArrayList、ArrayDeque、EnumSet、HashSet、LinkedHashSet、PriorityQueue、TreeSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ArrayList类：（拓展了AbstractList类）（实现了List接口）（泛型类）"><span class="toc-number">4.1.</span> <span class="toc-text">1. ArrayList类：（拓展了AbstractList类）（实现了List接口）（泛型类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-LinkedList类：（拓展了AbstracSequentialList类）（实现了List、Deque、Queue接口）（泛型类）"><span class="toc-number">4.2.</span> <span class="toc-text">2. LinkedList类：（拓展了AbstracSequentialList类）（实现了List、Deque、Queue接口）（泛型类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HashSet类：（拓展了AbstractSet类）（实现了Set接口）（泛型类）（无序）"><span class="toc-number">4.3.</span> <span class="toc-text">3. HashSet类：（拓展了AbstractSet类）（实现了Set接口）（泛型类）（无序）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-LinkedHashSet类：（拓展了HashSet类）（同样实现了Set接口）（泛型类）（有序）"><span class="toc-number">4.4.</span> <span class="toc-text">4. LinkedHashSet类：（拓展了HashSet类）（同样实现了Set接口）（泛型类）（有序）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-TreeSet类：（拓展了AbstractSet类）（实现了NavigableSet接口）（升序）（泛型类）"><span class="toc-number">4.5.</span> <span class="toc-text">5. TreeSet类：（拓展了AbstractSet类）（实现了NavigableSet接口）（升序）（泛型类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-PriorityQueue类：（拓展了AbstractQueue类）（实现了Queue接口）（使用比较器来比较存储）（泛型类）"><span class="toc-number">4.6.</span> <span class="toc-text">6. PriorityQueue类：（拓展了AbstractQueue类）（实现了Queue接口）（使用比较器来比较存储）（泛型类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-ArrayDeque类：（拓展了AbstractCollection类）（实现了Deque接口）（动态数组）（无容量限制）（泛型类）"><span class="toc-number">4.7.</span> <span class="toc-text">7. ArrayDeque类：（拓展了AbstractCollection类）（实现了Deque接口）（动态数组）（无容量限制）（泛型类）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迭代器"><span class="toc-number">5.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-迭代器Iterator：（适用于所有集合类）（遍历）（获取或移除元素）（泛型接口）"><span class="toc-number">5.1.</span> <span class="toc-text">1. 迭代器Iterator：（适用于所有集合类）（遍历）（获取或移除元素）（泛型接口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ListIterator：（拓展自Iterator接口）（实现了List接口的集合）（向前向后）（修改元素）"><span class="toc-number">5.2.</span> <span class="toc-text">2. ListIterator：（拓展自Iterator接口）（实现了List接口的集合）（向前向后）（修改元素）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用for-each迭代集合"><span class="toc-number">6.</span> <span class="toc-text">使用for-each迭代集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合中也可以存储自定义的类"><span class="toc-number">7.</span> <span class="toc-text">集合中也可以存储自定义的类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#映射（Map）"><span class="toc-number"></span> <span class="toc-text">映射（Map）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#映射接口"><span class="toc-number">1.</span> <span class="toc-text">映射接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Map接口（键值对，以键取值，键唯一，值不唯一）（泛型接口）"><span class="toc-number">1.1.</span> <span class="toc-text">1. Map接口（键值对，以键取值，键唯一，值不唯一）（泛型接口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SortedMap接口（升序）（泛型接口）"><span class="toc-number">1.2.</span> <span class="toc-text">2. SortedMap接口（升序）（泛型接口）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#映射类：AbstractMap、EnumMap、HashMap、TreeMap、WeakHashMap、LinkedHashMap、IdentityHashMap"><span class="toc-number">2.</span> <span class="toc-text">映射类：AbstractMap、EnumMap、HashMap、TreeMap、WeakHashMap、LinkedHashMap、IdentityHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-映射视图（实现了Collection及其子接口）"><span class="toc-number">2.1.</span> <span class="toc-text">1. 映射视图（实现了Collection及其子接口）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HashMap类：（拓展了AbstractMap类）（实现了Map接口）（使用哈希表存储映射）（泛型类）"><span class="toc-number">2.2.</span> <span class="toc-text">2. HashMap类：（拓展了AbstractMap类）（实现了Map接口）（使用哈希表存储映射）（泛型类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-TreeMap类：（拓展了AbstractMap类）（实现了NavigableMap接口）（映射存储在树结构中）（有序键值对）（快速检索）（升序存储）（泛型类）"><span class="toc-number">2.3.</span> <span class="toc-text">3. TreeMap类：（拓展了AbstractMap类）（实现了NavigableMap接口）（映射存储在树结构中）（有序键值对）（快速检索）（升序存储）（泛型类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-LinkedHashMap类：（拓展了HashMap类）（按插入顺序迭代映射）（泛型类）"><span class="toc-number">2.4.</span> <span class="toc-text">4. LinkedHashMap类：（拓展了HashMap类）（按插入顺序迭代映射）（泛型类）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#比较器Comparator：（TreeSet和TreeMap-（有序存储）（自然顺序排列）（泛型接口）"><span class="toc-number">3.</span> <span class="toc-text">比较器Comparator：（TreeSet和TreeMap)（有序存储）（自然顺序排列）（泛型接口）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合算法"><span class="toc-number">4.</span> <span class="toc-text">集合算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Arrays类：（数组操作方法）（连接集合与数组）"><span class="toc-number">5.</span> <span class="toc-text">Arrays类：（数组操作方法）（连接集合与数组）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-asList方法："><span class="toc-number">5.1.</span> <span class="toc-text">1. asList方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-binarySearch方法：二分查找"><span class="toc-number">5.2.</span> <span class="toc-text">2. binarySearch方法：二分查找</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 41
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/02</span><a class="archive-post-title" href= "/2020/03/02/SpringBoot/SpringBoot/" >SpringBoot</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/02</span><a class="archive-post-title" href= "/2020/03/02/Git/Git/" >Git</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/29</span><a class="archive-post-title" href= "/2020/02/29/Linux/Linux（Day1：基本命令/" >Linux(基本命令)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/28</span><a class="archive-post-title" href= "/2020/02/28/SSM/SSM框架整合/" >SSM框架整合</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/23</span><a class="archive-post-title" href= "/2019/11/23/SSM/SpringMVC/SpringMVC-Day2/" >SpringMVC(Day2)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/22</span><a class="archive-post-title" href= "/2019/11/22/SSM/SpringMVC/SpringMVC-Day1/" >SpringMVC(Day1)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/21</span><a class="archive-post-title" href= "/2019/11/21/SSM/Spring/Spring-Day3-声明式事务/" >Spring(Day3)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/20</span><a class="archive-post-title" href= "/2019/11/20/SSM/Spring/Spring-Day2-AOP/" >Spring(Day2)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/19</span><a class="archive-post-title" href= "/2019/11/19/SSM/Spring/Spring-Day1-Spring简介、Spring模块、IOC、DI、B/" >Spring(Day1)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/18</span><a class="archive-post-title" href= "/2019/11/18/SSM/Mybatis/MyBatis-Day4-缓存、插件、原理/" >MyBatis(Day4)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/18</span><a class="archive-post-title" href= "/2019/11/18/SSM/Mybatis/Mybatis-Day2-关联查询/" >Mybatis(关联映射)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/16</span><a class="archive-post-title" href= "/2019/11/16/SSM/Mybatis/Mybatis-Day1-基础知识/" >Mybatis(Day1)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/16</span><a class="archive-post-title" href= "/2019/11/16/log4j日志/Log4j日志/" >Log4j日志</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/15</span><a class="archive-post-title" href= "/2019/11/15/SSM/Mybatis/Mybatis-Day3-动态Sql/" >Mybatis(Day3)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2019/10/24/JavaWeb/JavaWeb-Redis非关系型数据库/" >JavaWeb(Redis非关系型数据库)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/22</span><a class="archive-post-title" href= "/2019/10/22/JavaWeb/JavaWeb(Filter、JQuery、Json、Ajax)/" >JavaWeb(Filter、JQuery、Json、Ajax)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/20</span><a class="archive-post-title" href= "/2019/10/20/JavaWeb/JavaWeb-实战-用户信息管理表/" >JavaWebs(MVC实战:用户信息管理表)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/19</span><a class="archive-post-title" href= "/2019/10/19/JavaWeb/JavaWeb(客户端会话技术：Cookie、Sessioin、JSP、EL)/" >[Untitled Post]</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/15</span><a class="archive-post-title" href= "/2019/10/15/JavaWeb/JavaWeb(TomCat、Servlet、HTTP(Request、Response、ServletContext))/" >JavaWeb(TomCat、Servlet、HTTP(Request/Response/ServletContext))</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/13</span><a class="archive-post-title" href= "/2019/10/13/JavaWeb/JavaWeb-前端(JavaScript)/" >JavaWeb(前端三板斧之JavaScript)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/12</span><a class="archive-post-title" href= "/2019/10/12/JavaWeb/JavaWeb-前端(CSS)/" >JavaWeb(前端三板斧之CSS)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span><a class="archive-post-title" href= "/2019/10/10/JavaWeb/JavaWeb-前端(HTML5)/" >JavaWeb(前端三板斧之HTML5)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/09</span><a class="archive-post-title" href= "/2019/10/09/JavaWeb/JavaWeb-Junit白盒测试、反射和注解/" >JavaWeb(Junit白盒测试、反射和注解)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/06</span><a class="archive-post-title" href= "/2019/10/06/JavaSe/JavaSe-JDBD/" >JavaSe:JDBD</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2019/10/05/MySql/MySQL基础/" >MySQL基础</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/24</span><a class="archive-post-title" href= "/2019/09/24/JavaSe/Java线程同步的三种方式/" >Java线程同步的三种方式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/22</span><a class="archive-post-title" href= "/2019/09/22/JavaSe/Java学习笔记(Day：15Java并发)/" >Java学习笔记(Day 15:Java并发)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/21</span><a class="archive-post-title" href= "/2019/09/21/JavaSe/Java学习笔记(Day 14：NIO)/" >Java学习笔记(Day 14:NIO)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/17</span><a class="archive-post-title" href= "/2019/09/17/JavaSe/Java学习笔记(Day 13Java.IO)/" >Java学习笔记(Day 13:Java.IO)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2019/09/15/JavaSe/Java学习笔记(Day 12：Java.util集合框架)/" >Java学习笔记(Day 12：Java.util:集合框架)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span><a class="archive-post-title" href= "/2019/09/10/JavaSe/Java学习笔记(Day 11：lambda表达式)/" >Java学习笔记(Day 11：lambda表达式)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/09</span><a class="archive-post-title" href= "/2019/09/09/JavaSe/Java学习笔记(Day 10：泛型)/" >Java学习笔记(Day 11：泛型)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span><a class="archive-post-title" href= "/2019/09/08/JavaSe/Java学习笔记(Day 9：注解）/" >Java学习笔记(Day 10:注解）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/07</span><a class="archive-post-title" href= "/2019/09/07/JavaSe/Java学习笔记(Day 8：枚举)/" >Java学习笔记(Day 9：枚举)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span><a class="archive-post-title" href= "/2019/09/05/JavaSe/Java学习笔记(Day 7：多线程）/" >Java学习笔记(Day 7:多线程)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/04</span><a class="archive-post-title" href= "/2019/09/04/JavaSe/Java学习笔记(Day 6：接口+异常)/" >Java学习笔记(Day 6:接口+异常)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/03</span><a class="archive-post-title" href= "/2019/09/03/JavaSe/Java学习笔记(Day 5：重写+重载+抽象类+访问权限）/" >Java学习笔记(Day 5：重写+重载+抽象类+访问权限）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2019/09/02/JavaSe/Java学习笔记(Day 4：继承+String+varargs/" >Java学习笔记(Day 4：继承+String+varargs)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/01</span><a class="archive-post-title" href= "/2019/09/01/JavaSe/Java学习笔记(Day3：this+成员变量+static关键字)/" >Java学习笔记（Day3：this+成员变量+static+final+super）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/31</span><a class="archive-post-title" href= "/2019/08/31/JavaSe/Java学习笔记(Day 1：数组+常用语句+二分查找)/" >Java学习笔记(Day 1：数组+常用语句+二分查找)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/31</span><a class="archive-post-title" href= "/2019/08/31/JavaSe/Java学习笔记(Day 2：跳转语句+类+方法)/" >Java学习笔记(Day 2:跳转语句+类+方法+构造函数+封装)</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Git"><span class="iconfont-archer">&#xe606;</span>Git</span>
    
        <span class="sidebar-tag-name" data-tags="JavaWeb"><span class="iconfont-archer">&#xe606;</span>JavaWeb</span>
    
        <span class="sidebar-tag-name" data-tags="Java"><span class="iconfont-archer">&#xe606;</span>Java</span>
    
        <span class="sidebar-tag-name" data-tags="JDBC"><span class="iconfont-archer">&#xe606;</span>JDBC</span>
    
        <span class="sidebar-tag-name" data-tags="JavaSe"><span class="iconfont-archer">&#xe606;</span>JavaSe</span>
    
        <span class="sidebar-tag-name" data-tags="MySQL"><span class="iconfont-archer">&#xe606;</span>MySQL</span>
    
        <span class="sidebar-tag-name" data-tags="Linux"><span class="iconfont-archer">&#xe606;</span>Linux</span>
    
        <span class="sidebar-tag-name" data-tags="SSM整合"><span class="iconfont-archer">&#xe606;</span>SSM整合</span>
    
        <span class="sidebar-tag-name" data-tags="Log4j"><span class="iconfont-archer">&#xe606;</span>Log4j</span>
    
        <span class="sidebar-tag-name" data-tags="SpringBoot"><span class="iconfont-archer">&#xe606;</span>SpringBoot</span>
    
        <span class="sidebar-tag-name" data-tags="Mybatis"><span class="iconfont-archer">&#xe606;</span>Mybatis</span>
    
        <span class="sidebar-tag-name" data-tags="Spring"><span class="iconfont-archer">&#xe606;</span>Spring</span>
    
        <span class="sidebar-tag-name" data-tags="SpringMVC"><span class="iconfont-archer">&#xe606;</span>SpringMVC</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "ks-39"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


